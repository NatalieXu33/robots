function u = solveStep1(A, g, d, b, dx, bx, dy, by, dim, param)
% Generates the solver from step1matrix.m and solve_Laplace.m to be 
% used in Split Bregman. 
% inputs:
% mu, lambda1, lambda2 are constants that depend on the data scale
% A is the matrix generated by the robot (or simulated paths)
% m and n are the dimensions of u and m*n should be the number of columns in A
% rhs = some function of g, A, etc.
% output: the reconstructed image u as a vector

tol = 10e-6;
max_iter = 40;    

lhs = @(u) makeLHS(A, u, dim, param);    
rhs = makeRHS(A, g, d, b, dx, bx, dy, by, dim, param);
preconditioner = @(f) solve_Laplace(f, dim, param);

[u ~] = pcg(lhs, rhs, tol, max_iter, preconditioner);

end

function lhs = makeLHS(A, u, dim, param)

[gradX gradY] = dirGradient(u, dim);

term1 = A'*(A*u);
term2 = u;
term3 = dirGradient(gradX, dim, 'transpose');
[~, term4] = dirGradient(gradY, dim, 'transpose');

lhs = param.mu*term1 + param.lambda1*term2 + param.lambda2*(term3 + term4);

end

function rhs = makeRHS(A, g, d, b, dx, bx, dy, by, dim, param)

term1 = A' * g;
term2 = (d - b);
[term3, ~] = dirGradient(dx-bx, dim, 'transpose');
[~, term4] = dirGradient(dy-by, dim, 'transpose');

rhs = param.mu*term1 + param.lambda1*term2 + param.lambda2*(term3 + term4);
    
end

function u = solve_Laplace(f, dim, param)
% solve the linear equation
% (lambda1*I + lambda2*Laplace)u = f
% in square domain of size (m, n)
% where Laplace is the Laplace operator in 2D

cx = [-1 zeros(1, dim(2)-2) 1];
cxT = [-1 1 zeros(1, dim(2)-2)];
cy = [-1 zeros(1, dim(1)-2) 1]';
cyT = [-1 1 zeros(1, dim(1)-2)]';
Cx = zeros(dim);
Cy = zeros(dim);

for ii=1:dim(1)
	Cx(ii,:) = fft(cxT) .* fft(cx);
end
for jj=1:dim(2)
	Cy(:,jj) = fft(cyT) .* fft(cy);
end

F = reshape(f, dim);
U = ifft2(fft2(F)./(param.lambda1*ones(dim) + param.lambda2*(Cx+Cy)));
u = reshape(U, prod(dim), 1);

end
